import { Telegraf, Markup } from "telegraf";
import { prisma } from "../services/prisma.js";
import { redis, rk } from "../services/redis.js";

type RoomInfo = {
  clientTgId: string;
  performerTgId: string;
  joined: Set<string>;
  active: boolean;
};

const getRoom = async (reqId: number): Promise<RoomInfo | undefined> => {
  const [hash, members] = await Promise.all([
    redis.hgetall(rk.roomHash(reqId)),
    redis.smembers(rk.roomJoined(reqId)),
  ]);
  if (!hash.clientTgId) return undefined;
  return {
    clientTgId: hash.clientTgId,
    performerTgId: hash.performerTgId,
    active: hash.active === "1" || hash.active === "true",
    joined: new Set(members),
  };
};

const ensureRoom = async (
  reqId: number,
  clientTgId: string,
  performerTgId: string,
): Promise<RoomInfo> => {
  await redis.hset(rk.roomHash(reqId), {
    clientTgId,
    performerTgId,
    active: "1",
  });
  return (await getRoom(reqId))!;
};

const joinRoom = async (reqId: number, tgId: string): Promise<Set<string>> => {
  await redis.sadd(rk.roomJoined(reqId), tgId);
  const members = await redis.smembers(rk.roomJoined(reqId));
  return new Set(members);
};

const leaveRoom = async (reqId: number, tgId: string): Promise<void> => {
  await redis.srem(rk.roomJoined(reqId), tgId);
};

export const registerRequestFlows = (bot: Telegraf) => {
  bot.on("callback_query", async (ctx, next) => {
    const data = (ctx.callbackQuery as any)?.data as string | undefined;
    if (!data) return next();

    if (data.startsWith("req_accept:")) {
      const id = Number(data.split(":")[1]);
      const req = await prisma.request.update({
        where: { id },
        data: { status: "ACCEPTED" },
        include: {
          client: true,
          performer: { include: { performerProfile: true } },
          paymentMeta: true,
        },
      });
      await ctx.editMessageText(`‚úÖ –ó–∞—è–≤–∫–∞ #${id} –ø—Ä–∏–Ω—è—Ç–∞. –í–ø–µ—Ä—ë–¥ –∫ –¥–µ—Ç–∞–ª—è–º!`);

      // –°–æ–∑–¥–∞—ë–º –∫–æ–º–Ω–∞—Ç—É –ø—Ä–æ–∫—Å–∏-—á–∞—Ç–∞ (–±–µ–∑ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤)
      await ensureRoom(id, String(req.client.tgId), String(req.performer.tgId));

      // –ï—Å–ª–∏ —É –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü—ã –µ—Å—Ç—å —Ä–µ–∫–≤–∏–∑–∏—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî —Å—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–∏–º –∫–ª–∏–µ–Ω—Ç—É –∏ —Å–æ—Ö—Ä–∞–Ω–∏–º
      const defaultPay =
        req.performer.performerProfile?.defaultPayInstructions?.trim();
      if (defaultPay) {
        if (!req.paymentMeta) {
          await prisma.paymentMeta.create({
            data: {
              requestId: req.id,
              proofUrls: [],
              instructions: defaultPay,
            },
          });
        } else if (!req.paymentMeta.instructions) {
          await prisma.paymentMeta.update({
            where: { requestId: req.id },
            data: { instructions: defaultPay },
          });
        }

        await ctx.telegram.sendMessage(
          Number(req.client.tgId),
          [
            `üÜï –û—Ç–ª–∏—á–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏: –∑–∞—è–≤–∫–∞ #${req.id} –ø—Ä–∏–Ω—è—Ç–∞.`,
            "",
            `üí¨ –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–∫—Å–∏-—á–∞—Ç —á–µ—Ä–µ–∑ –±–æ—Ç–∞ –∏ –æ–±—Å—É–¥–∏—Ç—å –¥–µ—Ç–∞–ª–∏ —Å –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü–µ–π.`,
            `üí≥ –†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è –æ–ø–ª–∞—Ç—ã:\n${defaultPay}`,
          ].join("\n"),
          Markup.inlineKeyboard([
            [
              Markup.button.callback(
                "üí¨ –û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç —á–µ—Ä–µ–∑ –±–æ—Ç–∞",
                `join_room:${req.id}`,
              ),
            ],
            [
              Markup.button.callback(
                "‚úÖ –û–ø–ª–∞—Ç–∏–ª",
                `client_mark_paid:${req.id}`,
              ),
            ],
          ]),
        );

        // –°–æ–æ–±—â–µ–Ω–∏–µ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü–µ ‚Äî –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø—Ä–æ /payinfo
        await ctx.reply(
          `üí¨ [–ß–∞—Ç –∑–∞—è–≤–∫–∏ #${id}] –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è.\n–û–±—Å—É–¥–∏—Ç–µ –¥–µ—Ç–∞–ª–∏ - –æ–±–º–µ–Ω—è–π—Ç–µ—Å—å –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏ –¥–ª—è —Å–≤—è–∑–∏, —Å–æ–≥–ª–∞—Å—É–π—Ç–µ –≤—Ä–µ–º—è, –¥–∞—Ç—É –∏ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏\n–†–µ–∫–≤–∏–∑–∏—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –∫–ª–∏–µ–Ω—Ç—É. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å: /payinfo`,
          Markup.inlineKeyboard([
            [
              Markup.button.callback(
                "üí¨ –û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç —á–µ—Ä–µ–∑ –±–æ—Ç–∞",
                `join_room:${id}`,
              ),
            ],
          ]),
        );
      } else {
        // –†–µ–∫–≤–∏–∑–∏—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã ‚Äî –ø–æ–ø—Ä–æ—Å–∏–º —É–∫–∞–∑–∞—Ç—å —á–µ—Ä–µ–∑ /payinfo –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
        await ctx.telegram.sendMessage(
          Number(req.client.tgId),
          [
            `üÜï –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ #${req.id} –ø—Ä–∏–Ω—è—Ç–∞.`,
            "",
            `üí¨ [–ß–∞—Ç –∑–∞—è–≤–∫–∏ #${req.id}] –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ–∫—Å–∏-—á–∞—Ç —á–µ—Ä–µ–∑ –±–æ—Ç–∞.`,
            `üí≥ [–û–ø–ª–∞—Ç–∞ –∑–∞—è–≤–∫–∏ #${req.id}] –†–µ–∫–≤–∏–∑–∏—Ç—ã –µ—â—ë –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü–µ–π.`,
          ].join("\n"),
          Markup.inlineKeyboard([
            [
              Markup.button.callback(
                "üí¨ –û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç —á–µ—Ä–µ–∑ –±–æ—Ç–∞",
                `join_room:${req.id}`,
              ),
            ],
            [
              Markup.button.callback(
                "‚úÖ –û–ø–ª–∞—Ç–∏–ª",
                `client_mark_paid:${req.id}`,
              ),
            ],
          ]),
        );

        await ctx.reply(
          `üí¨ [–ß–∞—Ç –∑–∞—è–≤–∫–∏ #${id}] –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è.\n–†–µ–∫–≤–∏–∑–∏—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã ‚Äî —É–∫–∞–∂–∏—Ç–µ –∏—Ö —á–µ—Ä–µ–∑ /payinfo –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–ª–∏–µ–Ω—Ç—É`,
          Markup.inlineKeyboard([
            [
              Markup.button.callback(
                "üí¨ –û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç —á–µ—Ä–µ–∑ –±–æ—Ç–∞",
                `join_room:${id}`,
              ),
            ],
          ]),
        );
      }

      return;
    }

    if (data.startsWith("req_reject:")) {
      const id = Number(data.split(":")[1]);
      const req = await prisma.request.update({
        where: { id },
        data: { status: "REJECTED" },
        include: { client: true },
      });
      await ctx.editMessageText(`‚ùé –ó–∞—è–≤–∫–∞ #${id} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.`);
      await ctx.telegram.sendMessage(
        Number(req.client.tgId),
        `–ó–∞—è–≤–∫–∞ #${id} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–º.`,
      );
      await redis.del(rk.roomHash(id), rk.roomJoined(id));
      return;
    }

    if (data.startsWith("join_room:")) {
      const reqId = Number(data.split(":")[1]);
      const req = await prisma.request.findUnique({
        where: { id: reqId },
        include: { client: true, performer: true },
      });
      if (!req) {
        await ctx.answerCbQuery?.("–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");
        return;
      }
      const r = await ensureRoom(
        reqId,
        String(req.client.tgId),
        String(req.performer.tgId),
      );
      if (!r.active) {
        await ctx.answerCbQuery?.("–ß–∞—Ç –∑–∞–∫—Ä—ã—Ç");
        return;
      }
      const me = String(ctx.from!.id);
      if (me !== r.clientTgId && me !== r.performerTgId) {
        await ctx.answerCbQuery?.("–í—ã –Ω–µ —É—á–∞—Å—Ç–Ω–∏–∫ —ç—Ç–æ–π –∑–∞—è–≤–∫–∏");
        return;
      }
      const joined = await joinRoom(reqId, me);
      await prisma.user.update({
        where: { tgId: me },
        data: { activeInChat: true, lastChatRequestId: reqId },
      });
      (ctx as any).session.proxyRoomFor = reqId;
      (ctx as any).session.lastChatRequestId = reqId;
      await ctx.answerCbQuery?.("–ß–∞—Ç –ø–æ–¥–∫–ª—é—á—ë–Ω ‚úÖ");
      await ctx.editMessageReplyMarkup({
        inline_keyboard: [
          [{ text: "üö™ –í—ã–π—Ç–∏ –∏–∑ —á–∞—Ç–∞", callback_data: `leave_room:${reqId}` }],
          [{ text: "‚ö†Ô∏è –ñ–∞–ª–æ–±–∞", callback_data: `report_req:${reqId}` }],
        ],
      });
      await ctx.reply(
        `üí¨ [–ß–∞—Ç –∑–∞—è–≤–∫–∏ #${reqId}] –í—ã –ø–æ–¥–∫–ª—é—á–µ–Ω—ã. –í—Å–µ –≤–∞—à–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –±—É–¥—É—Ç –¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –≤—Ç–æ—Ä–æ–π —Å—Ç–æ—Ä–æ–Ω–µ.`,
      );

      // deliver queued messages for this participant
      const qKey = rk.roomMsgQueue(reqId, me);
      const queued = await redis.lrange(qKey, 0, -1);
      if (queued.length) {
        for (const item of queued) {
          try {
            const payload = JSON.parse(item) as { from: string; msgId: number };
            // resend message preserving original sender
            await ctx.telegram.copyMessage(
              Number(me),
              Number(payload.from),
              payload.msgId,
            );
          } catch {}
        }
        await redis.del(qKey);
      }

      const meta = await prisma.paymentMeta.findUnique({
        where: { requestId: reqId },
      });
      if (meta && !meta.performerReceived && me === r.clientTgId) {
        const text = meta.paymentPending
          ? "‚è≥ –û–ø–ª–∞—Ç–∞ –æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è. –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–û–ø–ª–∞—Ç–∏–ª¬ª –ø–æ–≤—Ç–æ—Ä–Ω–æ."
          : "üí≥ –ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–ø–ª–∞—Ç–∏—Ç—å –∑–∞—è–≤–∫—É. –ù–∞–∂–º–∏—Ç–µ ¬´–û–ø–ª–∞—Ç–∏–ª¬ª, –∫–æ–≥–¥–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ –¥–µ–Ω—å–≥–∏.";
        await ctx.reply(
          text,
          Markup.inlineKeyboard([
            [Markup.button.callback("‚úÖ –û–ø–ª–∞—Ç–∏–ª", `client_mark_paid:${reqId}`)],
          ]),
        );
      }

      const bothIn = joined.has(r.clientTgId) && joined.has(r.performerTgId);
      if (bothIn) {
        const [clientWarn, perfWarn] = await redis.hmget(
          rk.roomHash(reqId),
          "clientWaitMsgId",
          "perfWaitMsgId",
        );
        if (clientWarn) {
          await ctx.telegram
            .deleteMessage(Number(r.clientTgId), Number(clientWarn))
            .catch(() => {});
        }
        if (perfWarn) {
          await ctx.telegram
            .deleteMessage(Number(r.performerTgId), Number(perfWarn))
            .catch(() => {});
        }
        await redis.hdel(
          rk.roomHash(reqId),
          "clientWaitMsgId",
          "perfWaitMsgId",
        );
        await ctx.telegram.sendMessage(
          Number(r.clientTgId),
          "–û–±–µ —Å—Ç–æ—Ä–æ–Ω—ã –≤ —á–∞—Ç–µ. –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—Ç—å—Å—è.",
        );
        await ctx.telegram.sendMessage(
          Number(r.performerTgId),
          "–û–±–µ —Å—Ç–æ—Ä–æ–Ω—ã –≤ —á–∞—Ç–µ. –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—Ç—å—Å—è.",
        );
      } else {
        const field = me === r.clientTgId ? "clientWaitMsgId" : "perfWaitMsgId";
        const oldWarn = await redis.hget(rk.roomHash(reqId), field);
        if (oldWarn) {
          await ctx.telegram
            .deleteMessage(Number(me), Number(oldWarn))
            .catch(() => {});
        }
        const warnMsg = await ctx.reply("–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∞ –Ω–µ –≤ —Å–µ—Ç–∏");
        await redis.hset(rk.roomHash(reqId), {
          [field]: String(warnMsg.message_id),
        });
      }
      return;
    }

    if (data.startsWith("leave_room:")) {
      const reqId = Number(data.split(":")[1]);
      const me = String(ctx.from!.id);
      await leaveRoom(reqId, me);
      await prisma.user.update({
        where: { tgId: me },
        data: { activeInChat: false, lastChatRequestId: reqId },
      });
      (ctx as any).session.proxyRoomFor = undefined;
      (ctx as any).session.lastChatRequestId = reqId;
      await ctx.answerCbQuery?.("–í—ã –≤—ã—à–ª–∏ –∏–∑ —á–∞—Ç–∞");
      await ctx.editMessageReplyMarkup(undefined);
      const r = await getRoom(reqId);
      if (r && r.active) {
        const peer = me === r.clientTgId ? r.performerTgId : r.clientTgId;
        if (r.joined.has(peer)) {
          const field =
            peer === r.clientTgId ? "clientWaitMsgId" : "perfWaitMsgId";
          const oldWarn = await redis.hget(rk.roomHash(reqId), field);
          if (oldWarn) {
            await ctx.telegram
              .deleteMessage(Number(peer), Number(oldWarn))
              .catch(() => {});
          }
          const warn = await ctx.telegram.sendMessage(
            Number(peer),
            "–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∞ –Ω–µ –≤ —Å–µ—Ç–∏",
          );
          await redis.hset(rk.roomHash(reqId), {
            [field]: String(warn.message_id),
          });
        }
      }
      return;
    }

    if (data.startsWith("show_payment:")) {
      const id = Number(data.split(":")[1]);
      const meta = await prisma.paymentMeta.findUnique({
        where: { requestId: id },
      });
      const body = meta?.instructions
        ? `üí≥ [–û–ø–ª–∞—Ç–∞ –∑–∞—è–≤–∫–∏ #${id}]\n${meta.instructions}`
        : `üí≥ [–û–ø–ª–∞—Ç–∞ –∑–∞—è–≤–∫–∏ #${id}]\n–†–µ–∫–≤–∏–∑–∏—Ç—ã –µ—â—ë –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü–µ–π.`;
      await ctx.reply(body);
      return;
    }

    if (data.startsWith("client_mark_paid:")) {
      const id = Number(data.split(":")[1]);
      await prisma.paymentMeta.update({
        where: { requestId: id },
        data: { clientMarkPaid: true, paymentPending: true },
      });
      await ctx.editMessageText(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω/—Ñ–æ—Ç–æ/–¥–æ–∫—É–º–µ–Ω—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
      );
      (ctx as any).session.awaitingProofFor = id;
      return;
    }

    if (data.startsWith("perf_got_money:")) {
      const id = Number(data.split(":")[1]);
      const req = await prisma.request.update({
        where: { id },
        data: { status: "COMPLETED" },
        include: { client: true },
      });
      await prisma.paymentMeta.update({
        where: { requestId: id },
        data: { performerReceived: true, paymentPending: false },
      });
      await ctx.editMessageText(
        `‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –ó–∞—è–≤–∫–∞ #${id} –∑–∞–≤–µ—Ä—à–µ–Ω–∞.`,
      );
      await ctx.telegram.sendMessage(
        Number(req.client.tgId),
        "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü–∞ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ. –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –≤—Ä–µ–º—è–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏—è!",
      );
      const r = await getRoom(id);
      if (r) {
        await redis.hset(rk.roomHash(id), { active: "0" });
        await redis.del(rk.roomJoined(id));
        await ctx.telegram.sendMessage(
          Number(r.clientTgId),
          "–ß–∞—Ç –∑–∞—è–≤–∫–∏ –∑–∞–∫—Ä—ã—Ç.",
        );
        await ctx.telegram.sendMessage(
          Number(r.performerTgId),
          "–ß–∞—Ç –∑–∞—è–≤–∫–∏ –∑–∞–∫—Ä—ã—Ç.",
        );
        await prisma.user.update({
          where: { tgId: r.clientTgId },
          data: { activeInChat: false, lastChatRequestId: null },
        });
        await prisma.user.update({
          where: { tgId: r.performerTgId },
          data: { activeInChat: false, lastChatRequestId: null },
        });
      }
      return;
    }

    return next();
  });

  bot.on(["photo", "document"], async (ctx, next) => {
    const awaiting = (ctx as any).session.awaitingProofFor as
      | number
      | undefined;
    if (!awaiting) return next();
    const fileIds: string[] = [];
    if ("photo" in ctx.message! && (ctx.message as any).photo?.length) {
      fileIds.push(
        (ctx.message as any).photo[(ctx.message as any).photo.length - 1]
          .file_id,
      );
    }
    if ("document" in ctx.message! && (ctx.message as any).document) {
      fileIds.push((ctx.message as any).document.file_id);
    }
    await prisma.paymentMeta.update({
      where: { requestId: awaiting },
      data: { proofUrls: { push: fileIds } },
    });
    const req = await prisma.request.findUnique({
      where: { id: awaiting },
      include: { performer: true },
    });
    if (req) {
      await ctx.telegram.sendMessage(
        Number(req.performer.tgId),
        `–ö–ª–∏–µ–Ω—Ç –∑–∞–≥—Ä—É–∑–∏–ª –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–ø–ª–∞—Ç—ã –ø–æ –∑–∞—è–≤–∫–µ #${awaiting}. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ.`,
        Markup.inlineKeyboard([
          [Markup.button.callback("–ü–æ–ª—É—á–µ–Ω–æ", `perf_got_money:${awaiting}`)],
        ]),
      );
    }
    await ctx.reply(
      "–°–ø–∞—Å–∏–±–æ! –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ. –û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∏—Ü—ã.",
    );
    (ctx as any).session.awaitingProofFor = undefined;
  });

  const relayableUpdates = [
    "text",
    "photo",
    "voice",
    "audio",
    "video",
    "document",
    "sticker",
  ];
  bot.on(relayableUpdates as any, async (ctx, next) => {
    if ((ctx as any).session.awaitingProofFor) return next();

    const roomId = (ctx as any).session.proxyRoomFor as number | undefined;
    if (!roomId) return next();
    const r = await getRoom(roomId);
    if (!r || !r.active) return next();

    const me = String(ctx.from!.id);
    if (!r.joined.has(me)) return next();

    const peer = me === r.clientTgId ? r.performerTgId : r.clientTgId;
    const messageId = (ctx.message as any).message_id as number;

    const peerRec = await prisma.user.findUnique({
      where: { tgId: peer },
      select: { activeInChat: true },
    });

    if (peerRec?.activeInChat && r.joined.has(peer)) {
      try {
        // @ts-expect-error telegraf types
        await ctx.telegram.copyMessage(Number(peer), ctx.chat!.id, messageId);
      } catch {}
    } else {
      // store message for later delivery
      await redis.rpush(
        rk.roomMsgQueue(roomId, peer),
        JSON.stringify({ from: me, msgId: messageId }),
      );
    }
  });
};
